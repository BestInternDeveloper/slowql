# SlowQL

RDBMS written in Haskell for fun (and for suffering).

## 构建运行

SlowQL使用Haskell编写。要运行测试用例，你需要安装[stack](https://docs.haskellstack.org/en/stable/install_and_upgrade/)，然后执行

```
stack test # 目前只支持测试用例
```

或者运行现成的Binary。

## 模块划分

SlowQL主要划分为文件系统、记录管理、索引管理、系统管理、查询解析等模块。

文件系统为一个模拟的带缓存页式文件系统，可以认为能够支持惰性读和写操作；记录管理为数据的主要来源，支持基础的数据操作；索引管理模块提供按B+树存储的数据，以加快查询操作和实现部分约束（如unique约束）；系统管理模块负责管理“数据库”本身，例如管理数据表和索引等；查询解析模块接受SQL语句，根据索引等构造优化的查询表达式，并且进行查询操作。


### 文件系统

SlowQL重新实现了基于LRU缓存的文件系统，并提供了供上层使用的IO Monad接口，这使得上层数据库逻辑能够与底层文件的管理解耦合，并且能够使用无副作用的纯函数实现。

#### 惰性IO

分页文件系统满足以下性质：当文件被文件系统打开时，一些IO操作与纯函数具有类似的性质。

1. 在只有读操作的情况下，对``SlowQL.PageFS.readPage``的调用总会产生相同的值。
2. 在同时有读写操作的情况下，读页面会导致读入“最新”的页面状态。

因此我们可以认为“读取页面”的操作是一个惰性的IO操作，即它可以在任意位置、以任意顺序按照需要调用，而不会影响运算结果。考虑到Haskell默认IO的强制立即求值性质，我们使用``unsafeInterleaveIO``来包装读页面的函数使得它能够参与到惰性求值中。（可以考虑用[iteratee](http://hackage.haskell.org/package/iteratee)改写） 

### 记录管理（表管理）

“数据表”应当作为主信息源出现，提供最基本的增删改查操作，并且支持在数据表的基础上创建索引、约束等。

#### 接口

记录管理系统提供了查询、单个插入和单点修改（删除）的接口。

查询功能，SlowQL提供了查询接口foldrQuery（即reduce操作），用于抽象“对数据表的顺序访问操作”。

此外，SlowQL还支持单条插入和删除、修改单条数据的操作。

#### 数据类型

SlowQL内部使用TParam和TValue来表示数据类型及数据的值，例如，当数据类型失配时会抛出TypeMismatch错误，当违反空约束时会抛出NullValue错误等。

（TODO:通过约束和索引实现更复杂的检查，例如重复检查、外键检查等）

### 索引管理

索引应当作为原始数据表的冗余出现，根据选择的列构建原始数据表的B+树，并且能够随数据表联动变化。

简便起见，SlowQL的索引为原始数据表的完全冗余，即索引存储的内容为原始数据表的所有内容。

TableIndex实现了一个简单的B+树结构：节点分为中间节点和叶子节点两种，中间节点只存储用于比较的键值，叶子节点存储具体的数据；平级节点存在指向sibling的指针，使得横向遍历成为可能。
TableIndex支持“从某叶子开始的线性查询”（因为使用了链表所以保证了线性复杂度），以及任意的单点插入删除操作。

在设计上，TableIndex对数据表的结构是无知的：TableIndex只是一棵“外置比较器的存放字节串的B+树”，需要在查询、插入、删除时具体指明比较器和键提取器。这使得B+树的实现能够与数据库本身的设计解耦合，并且根据需要调整TableIndex的冗余程度（例如调整至只保存RID/指针等）。

（TODO：
1. 实现索引管理和记录管理的级联（cascade）：记录内应当保存原始记录的指针。
2. 调整TableIndex的冗余程度？注意到假如只保存RID/指针，则平均一定多一次访问硬盘操作；假如保存全部内容，占地大（极限用冗余换效率）
3. 严重的效率问题？需要Profile。
）
### 系统管理

一方面“管理所有的表和索引”是一个规模较小的任务，可以简单完成；另一方面，系统管理应当完成数据表和索引的综合任务……
（TODO）

### 查询解析

（TODO）

## 附加内容

（TODO）

## 测试用例

所有的测试用例都置于test/SlowQL/Test目录下。

### TestRecord

该测例是一个对记录管理模块部分功能的测试：打开文件，插入10000条记录，然后关闭文件，再次打开，检查元信息正确性和记录数。

该测试用例展示了记录管理模块的基本接口foldrQuery的最简单使用：构造一条包含所有记录的列表（fold函数是(:)）。你可以根据foldr的特性构造更多的运算（例如map和filter，关于filter的构造可以参考Table中“过滤掉被删除掉的记录”的实现）。需要注意的是整个过程都是惰性的，因此假如foldr函数不需要接下来的值（例如，你的操作是一个可以被布尔短路的与/或操作，或者你只需要列表的第一个值），它们将不会被计算。这一特性在执行查询操作时“先构造查询表达式、后进行实际运算”会很有帮助。

### TestRecord(2)

一个向索引中插入数据的测试用例。