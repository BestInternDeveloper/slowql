# SlowQL

RDBMS written in Haskell for fun (and for suffering).

## Changelog ver.3

1. 为解决已有的若干问题，SlowQL在原有代码基础上进行了大量重构，例如摒除了Lazy I/O转用Iteratee(Conduit)，将线性表抽象为单独的数据结构等。例如，重构后的线性表使用了类似于过程式语言的实现方式（大量使用就地操作），一方面解决了原有实现的低效率问题，同时给上层应用（数据表）暴露了抽象的、易用的接口。（WIP：B+树）故该文档比起之前版本有较大重写。
2. 系统管理：简单的REPL，创建删除数据库。

## 构建运行

SlowQL使用Haskell编写。要运行测试用例，你需要安装[stack](https://docs.haskellstack.org/en/stable/install_and_upgrade/)，然后执行

```
stack run #启动交互式命令行，输入\q退出。
stack test # 目前只支持测试用例
```

或者运行现成的Binary。

## 模块划分

SlowQL主要划分为文件系统、记录管理、索引管理、系统管理、查询解析等模块。

文件系统为一个模拟的带缓存页式文件系统，可以认为能够支持惰性读和写操作；记录管理为数据的主要来源，支持基础的数据操作；索引管理模块提供按B+树存储的数据，以加快查询操作和实现部分约束（如unique约束）；系统管理模块负责管理“数据库”本身，例如管理数据表和索引等；查询解析模块接受SQL语句，根据索引等构造优化的查询表达式，并且进行查询操作。


### 文件系统

SlowQL重新实现了基于LRU缓存的文件系统，并提供了供上层使用的IO Monad接口，这使得上层数据库逻辑能够与底层文件的管理解耦合，并且能够使用无副作用的纯函数实现。

#### Iteratee

SlowQL使用了[iteratee](http://hackage.haskell.org/package/iteratee)的思路对数据进行管理：SlowQL首先实现了若干种简单的底层文件数据结构（文件上的线性表、文件上的B+树等），并且将“数据结构提供数据”作为数据结构的接口，而各种关系代数操作和输出到屏幕的操作只需要逐级接收这些数据并进行计算。

Iteratee允许在语法上将不同的数据库元素（数据表、索引、关系代数操作）组装在一起，并且使得数据的流动构成了一条完整的流水线而提高效率。另一方面，Iteratee模式可以自动完成对资源的管理（enumerator内部采用RAII的写法，每次只读入一块数据并且释放所有资源），而不需要把管理资源的责任交给语言的垃圾回收器，从而提高了效率。

### 记录管理（表管理）

“数据表”应当作为主信息源出现，提供最基本的增删改查操作，并且支持在数据表的基础上创建索引、约束等。

#### 接口

记录管理系统提供了查询、条件插入、条件修改、条件删除的接口。

查询功能，SlowQL提供了线性操作，用于抽象“对数据表的顺序访问操作”。

此外，SlowQL还支持条件插入、删除、修改数据的操作，用于配合相应的SQL语句。

#### 数据类型

SlowQL内部使用TParam和TValue来表示数据类型及数据的值，例如，当数据类型失配时会抛出TypeMismatch错误，当违反空约束时会抛出NullValue错误等。

SlowQL的上层数据类型与下层是分离的，这有利于上下层分离进行针对性的优化。

（TODO:通过约束和索引实现更复杂的检查，例如重复检查、外键检查等）

### 索引管理

索引应当作为原始数据表的冗余出现，根据选择的列构建原始数据表的B+树，并且能够随数据表联动变化。

简便起见，SlowQL的索引为原始数据表的完全冗余，即索引存储的内容为原始数据表的所有内容。

TableIndex实现了一个简单的B+树结构：节点分为中间节点和叶子节点两种，中间节点只存储用于比较的键值，叶子节点存储具体的数据；平级节点存在指向sibling的指针，使得横向遍历成为可能。
TableIndex支持“从某叶子开始的线性查询”（因为使用了链表所以保证了线性复杂度），以及任意的单点插入删除操作。

在设计上，TableIndex对数据表的结构是无知的：TableIndex只是一棵“外置比较器的存放字节串的B+树”，需要在查询、插入、删除时具体指明比较器和键提取器。这使得B+树的实现能够与数据库本身的设计解耦合，并且根据需要调整TableIndex的冗余程度（例如调整至只保存RID/指针等）。

（TODO：
1. 实现索引管理和记录管理的级联（cascade）：记录内应当保存原始记录的指针。
2. 调整TableIndex的冗余程度？注意到假如只保存RID/指针，则平均一定多一次访问硬盘操作；假如保存全部内容，占地大（极限用冗余换效率）
3. 严重的效率问题？需要Profile。
）

（ChangeLog:TableIndex仍然使用完全冗余，并试图通过重构解决效率问题。）

### 系统管理

一方面“管理所有的表和索引”是一个规模较小的任务，可以简单完成（不需要考虑存储效率）；另一方面，系统管理应当完成数据表和索引的综合任务。

SlowQL将工作目录下的slowql-data文件夹作为数据的存储路径，slowql-data下的每个文件夹存放一个数据库。每个数据库内以简单的二进制串存储该数据库的基本信息（.slowql文件）。

当一个数据库被使用时，出于高效与简单起见所有的数据表都会被打开，等待使用。

最后，SlowQL提供了一个简单的REPL，供输入SQL语句以获得查询结果。这个REPL将作为SlowQL的主入口使用。

### 查询解析

SQL语句的编译器通过happy生成（文法参见src/SlowQL/SQL/Parser.y），……
（TODO）

## 附加内容

（TODO：
1. 新索引类型：跳表（接口与B+树完全一致，但比B+树易于实现）？哈希？
2. 聚集操作？(只需要多一层流水线)
3. UI？
）

## 测试用例

所有的测试用例都置于test/SlowQL/Test目录下。

### SlowQL.Test.LinearTableTest

对线性表的简单测试。